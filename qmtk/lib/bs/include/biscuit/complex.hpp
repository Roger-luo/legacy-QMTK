#ifndef BS_COMPLEX_INC
#define BS_COMPLEX_INC

#include <complex>

namespace bs {

// template <typename ta, typename tb>
// inline std::complex<dtype> operator+(std::complex<dtype> &lhs, dtype &rhs)
// {
//   return lhs + std::complex<dtype>(0, rhs);
// }

// template <typename dtype>
// inline std::complex<dtype> operator-(std::complex<dtype> &lhs, dtype &rhs)
// {
//   return lhs - std::complex<dtype>(0, rhs);
// }

// template <typename dtype>
// inline std::complex<dtype> operator*(std::complex<dtype> &lhs, dtype &rhs)
// {
//   return lhs * std::complex<dtype>(0, rhs);
// }

// template <typename dtype>
// inline std::complex<dtype> operator/(std::complex<dtype> &lhs, dtype &rhs)
// {
//   return lhs / std::complex<dtype>(0, rhs);
// }

// template <typename dtype>
// inline std::complex<dtype> operator+(dtype &lhs, std::complex<dtype> &rhs)
// {
//   return std::complex<dtype>(0, lhs) + rhs;
// }

// template <typename dtype>
// inline std::complex<dtype> operator-(dtype &lhs, std::complex<dtype> &rhs)
// {
//   return std::complex<dtype>(0, lhs) - rhs;
// }

// template <typename dtype>
// inline std::complex<dtype> operator*(dtype &lhs, std::complex<dtype> &rhs)
// {
//   return std::complex<dtype>(0, lhs) * rhs;
// }

// template <typename dtype>
// inline std::complex<dtype> operator/(dtype &lhs, std::complex<dtype> &rhs)
// {
//   return std::complex<dtype>(0, lhs) / rhs;
// }

} // namespace bs

#endif // BS_COMPLEX_INC
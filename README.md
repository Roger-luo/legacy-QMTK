# VMC

VMC is a python package that can interactive with PyTorch. It offers MCMC sampling methods and hamiltonians and related autograds.

# Dependencies

### required:

- **pytorch**
- **numpy**

### optional:

for lattice animation:

- **matplotlib**
- **moviepy**

# example code

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.autograd import Variable

from vmc.sampler import STMetropolis
from vmc.ham import TFI


# local energy
def eloc(x):
    ret = sum(val * model(Variable(config))
              for config, val in hamiltonian.nnz(x))
    return ret / model(Variable(x))

# proposal probability distribution


def proposal(x):
    amp = model(Variable(x))
    return abs(amp.data[0])**2


model = MLP(5, 12, 1)
hamiltonian = TFI(5, h=1, pbc=True)

sampler = STMetropolis(proposal=proposal, size=5)
optimizer = optim.Adam(model.parameters())

for epoch in range(1000):
    print('epoch %s' % epoch)
    configs = sampler.sample(itr=500, burn=100, thin=1)
    energy = 0.0
    for config in configs:
        loss = eloc(config)
        energy += loss
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    print(energy / 500)

```

# Structure

there are two modules in this package.

# Sampler

# sampler
samplers are subclass of `SamplerBase`, each sampler should implement methods below:

- `step` step methods for each samplling step
- `sample` a API for sampling, returns a collector

There are some other methods that may not need to be modified:

- `measure` measure an operator(TODO: statistics)


Currently, sampling methods below is implemented:

- [x] `STMetropolis` Single thread metropolis
- [ ] `MPMetropolis` Multi - process metropolis
- [ ] `Metropolis` an unified API for metropolis method

Here are some example code for sampler:

```python
```

# collector

Collector aims to help sampler manage memories. Each sample generated by sampler will be collected by a collector. All the collector are subclass of `CollectorBase`, each collector should be an ** iterator class**

Methods below should be implemented by a collector:

- `__get__` allows random access to each sample
- `collect` collects inputs
- `__iter__` iterable definitions for the collector


Here are some example code for collector

```python

collector = STMetropolis(proposal, size)

while _curr_itr < itr:
    sample, accept = step(inverse=inverse)
    _curr_itr += 1
    if _curr_itr % thin == 0:
        collector.collect(sample, accept)
```


# Ham

Hamiltonian package offers methods for constructing hamiltonian.

## lattice

lattice module offers methods to iterate defined lattice, eg. chain lattice, square lattice.

each lattice offer `grid` to iterate all the neighbors, for example, the following code iterates all the nearest neighbors on a square lattice with periodic boundary condition.

```python

lattice = Square((5, 5), pbc=True)

for i, j in lattice.grid(nn=1)
    print(i, j)

```

To see how it iterates all the neighbors, an animation can be write as follows:

```python
    import matplotlib.pyplot as plt
    from moviepy.video.io.bindings import mplfig_to_npimage
    import moviepy.editor as mpy
    duration = 2

    lattice = Square((3, 4), pbc=True)
    x1 = []
    y1 = []
    x2 = []
    y2 = []
    count = 0
    nodes = list(lattice.grid(nn=0))
    nearest = list(lattice.grid(nn=1))
    nextnearest = list(lattice.grid(nn=2))
    print(nodes, len(nodes))
    print(nearest, len(nearest))
    print(nextnearest, len(nextnearest))
    fig_mpl, ax = plt.subplots(1, figsize=(5, 5), facecolor='white')
    # ANIMATE WITH MOVIEPY (UPDATE THE CURVE FOR EACH t). MAKE A GIF.
    count = 0
    ax.set_xlim(-0.5, 2.5)
    ax.set_ylim(-0.5, 3.5)
    plt.grid()

    lines = nextnearest

    def make_frame_mpl(t):
        global count
        if count < len(lines):
            a, b = lines[count]
            ax.plot([a[0], b[0]],
                    [a[1], b[1]], 'bo-')
            count += 1
        return mplfig_to_npimage(fig_mpl)  # RGB image of the figure

    animation = mpy.VideoClip(make_frame_mpl, duration=duration)
    # animation.write_gif("sinc_mpl.gif", fps=20)
    animation.write_videofile("my_animation.mp4", fps=24)

```

## Hamiltonian

Hamiltonians are iteratable subclasses of `HamiltonianBase`. Each hamiltonian will offer two methods to access its elements:

- `nnz(self, config)` an iterator that iterates all non-zeros elements with related configurations
- `mat(self)` returns the matrix representation of the hamiltonian

Following hamiltonians is implemented:

- [x] Traverse Field Ising Model (TFI)
- [x] J1J2
- [x] Local-1 Pauli operators
- [x] Loacl-2 Pauli operators
